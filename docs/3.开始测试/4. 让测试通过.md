## 本节说明

上一节中，我们的创建并成功运行了第一个测试，这一节我们一起来让测试通过。

## 路由不存在

报错「路由不存在」，这很正常，因为我们没有创建，进入 routes/web.php 中，内容替换为以下：

*web.php*

```
<?php

use Illuminate\Support\Facades\Route;

Route::get('/questions', 'QuestionsController@index');
```

保存后再次运行测试：

![让测试通过](https://cdn.learnku.com/uploads/images/202007/20/19192/9rLE3kH2Cs.png!large)

默认情况下，Laravel 为我们将异常渲染成 500 响应，在这里我们需要暴露异常，所以我们修改下测试：

*tests/Feature/ViewQuestionsTest.php*

```
<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;

class ViewQuestionsTest extends TestCase
{
    public function testUserCanViewQuestions()
    {
        // 0. 抛出异常 
        $this->withoutExceptionHandling();

        // 1. 访问链接 questions
        $test = $this->get('/questions');

        // 2. 正常返回 200
        $test->assertStatus(200);
    }
}

```

保存后再次运行测试，即可看到详细的报错信息：

![让测试通过](https://cdn.learnku.com/uploads/images/202103/24/1/k8qx3DVWdO.png!large)

注意看报错的是 `Target class [QuestionsController]...` 这个类不存在，注意到命名空间缺失，我们还需要前往路由的服务提供者类中设置命名空间：

*app/Providers/RouteServiceProvider.php*

```
<?php
.
.
.
class  RouteServiceProvider  extends  ServiceProvider
{
    .
    .
    .
    protected  $namespace =  'App\\Http\\Controllers'; // 取消这一行的注释
    .
    .
    .
}
```

此文件中有这样的代码：

```
Route::middleware('web')
    ->namespace($this->namespace)
    ->group(base_path('routes/web.php'));
```

以上代码将使用`$namespace`作为`routes/web.php`路由文件中的命名前缀，这样允许我们在路由中使用简短的`Class@Method`格式。

再次运行：

```
$ phpunit
```

会出现：

![让测试通过](https://cdn.learnku.com/uploads/images/202007/20/19192/XliJY3C8RO.png!large)

可以看到同样报了控制器不存在的错误，但是此时的控制器命名空间是对的，只不过我们的文件确实不存在。

此时我们浏览器访问 http://zhihu.test/questions 可以看到相同的报错：

![让测试通过](https://cdn.learnku.com/uploads/images/202005/30/19192/u4gvzlzhYf.png!large)

控制器不存在，那我们就创建控制器：

```
$ php artisan make:controller QuestionsController
```

再次运行测试：

![让测试通过](https://cdn.learnku.com/uploads/images/202006/08/19192/PfbpJ9vPTe.png!large)

`index()`方法不存在那我们就创建方法：

*app/Http/Controllers/QuestionsController.php*

```
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class QuestionsController extends Controller
{
    public function index()
    {
    }
}

```

可以看到运行测试，成功通过：

![让测试通过](https://cdn.learnku.com/uploads/images/202005/30/19192/cLc8rKk818.png!large)

此时我们浏览器访问 http://zhihu.test/questions 可以看到访问成功：

![让测试通过](https://cdn.learnku.com/uploads/images/202005/30/19192/PZ1Sb7eoc3.png!large)

## 自动化测试

在以上的测试中，我们有意让大家对比浏览器访问与使用测试套件访问的结果，可以看到，这就是自动化测试的核心概念，运行一个命令，就直接模拟用户去浏览器测试。

浏览器访问并确定访问正确，这其实也是一个测试，我们称为人工测试。而代码测试，我们称为自动化测试。想象一下，如果一个应用需要成百上千个测试，才能保证其可用性。例如说像
zhihu.com 站点上有那么多页面，要确保每个页面皆可访问且功能完善。每一次修改代码上线，使用人工测试跑一遍，耗费人力实在太大，完全是不可行的。而如果有代码的自动化测试，那就很方便，直接一个命令，就会自动跑所有的代码测试。

如上所述，浏览器测试是一个简单的对比，本课程讲授的是 TDD 测试，在 TDD 中，我们很少使用浏览器确认，所以在接下来的章节中，我们将很少使用浏览器。

当然，一开始你可能对测试的访问结果不信任，这种情况你可以随时打开浏览器进行查看，慢慢构建信任。

## 总结

目前为止，我们编写了第一个测试，且成功让测试通过。接下来我们将补一下一些测试相关小知识。

## 提交代码

让我们将本次更改纳入版本控制中：

```
$ git add -A
$ git commit -m "test view questions"
```
